// chartjs-plugin-zoom@2.2.0 downloaded from https://ga.jspm.io/npm:chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.esm.js

import e from"hammerjs";import{each as t,valueOrDefault as n,almostEquals as o,callback as a,sign as i,getRelativePosition as r,_isPointInArea as c}from"chart.js/helpers";const getModifierKey=e=>e&&e.enabled&&e.modifierKey;const keyPressed=(e,t)=>e&&t[e+"Key"];const keyNotPressed=(e,t)=>e&&!t[e+"Key"];function directionEnabled(e,t,n){return e===void 0||(typeof e==="string"?e.indexOf(t)!==-1:typeof e==="function"&&e({chart:n}).indexOf(t)!==-1)}function directionsEnabled(e,t){typeof e==="function"&&(e=e({chart:t}));return typeof e==="string"?{x:e.indexOf("x")!==-1,y:e.indexOf("y")!==-1}:{x:false,y:false}}function debounce(e,t){let n;return function(){clearTimeout(n);n=setTimeout(e,t);return t}}function getScaleUnderPoint({x:e,y:t},n){const o=n.scales;const a=Object.keys(o);for(let n=0;n<a.length;n++){const i=o[a[n]];if(t>=i.top&&t<=i.bottom&&e>=i.left&&e<=i.right)return i}return null}function getEnabledScalesByPoint(e,n,o){const{mode:a="xy",scaleMode:i,overScaleMode:r}=e||{};const c=getScaleUnderPoint(n,o);const s=directionsEnabled(a,o);const l=directionsEnabled(i,o);if(r){const e=directionsEnabled(r,o);for(const t of["x","y"])if(e[t]){l[t]=s[t];s[t]=false}}if(c&&l[c.axis])return[c];const m=[];t(o.scales,(function(e){s[e.axis]&&m.push(e)}));return m}const s=new WeakMap;function getState(e){let t=s.get(e);if(!t){t={originalScaleLimits:{},updatedScaleLimits:{},handlers:{},panDelta:{},dragging:false,panning:false};s.set(e,t)}return t}function removeState(e){s.delete(e)}function zoomDelta(e,t,n,o){const a=Math.max(0,Math.min(1,(e-t)/n||0));const i=1-a;return{min:o*a,max:o*i}}function getValueAtPoint(e,t){const n=e.isHorizontal()?t.x:t.y;return e.getValueForPixel(n)}function linearZoomDelta(e,t,n){const o=e.max-e.min;const a=o*(t-1);const i=getValueAtPoint(e,n);return zoomDelta(i,e.min,o,a)}function logarithmicZoomRange(e,t,n){const o=getValueAtPoint(e,n);if(o===void 0)return{min:e.min,max:e.max};const a=Math.log10(e.min);const i=Math.log10(e.max);const r=Math.log10(o);const c=i-a;const s=c*(t-1);const l=zoomDelta(r,a,c,s);return{min:Math.pow(10,a+l.min),max:Math.pow(10,i-l.max)}}function getScaleLimits(e,t){return t&&(t[e.id]||t[e.axis])||{}}function getLimit(e,t,o,a,i){let r=o[a];if(r==="original"){const o=e.originalScaleLimits[t.id][a];r=n(o.options,o.scale)}return n(r,i)}function linearRange(e,t,n){const o=e.getValueForPixel(t);const a=e.getValueForPixel(n);return{min:Math.min(o,a),max:Math.max(o,a)}}function fixRange(e,{min:t,max:n,minLimit:a,maxLimit:i},r){const c=(e-n+t)/2;t-=c;n+=c;const s=r.min.options??r.min.scale;const l=r.max.options??r.max.scale;const m=e/1e6;o(t,s,m)&&(t=s);o(n,l,m)&&(n=l);if(t<a){t=a;n=Math.min(a+e,i)}else if(n>i){n=i;t=Math.max(i-e,a)}return{min:t,max:n}}function updateRange(e,{min:t,max:n},o,a=false){const i=getState(e.chart);const{options:r}=e;const c=getScaleLimits(e,o);const{minRange:s=0}=c;const l=getLimit(i,e,c,"min",-Infinity);const m=getLimit(i,e,c,"max",Infinity);if(a==="pan"&&(t<l||n>m))return true;const d=e.max-e.min;const u=a?Math.max(n-t,s):d;if(a&&u===s&&d<=s)return true;const f=fixRange(u,{min:t,max:n,minLimit:l,maxLimit:m},i.originalScaleLimits[e.id]);r.min=f.min;r.max=f.max;i.updatedScaleLimits[e.id]=f;return e.parse(f.min)!==e.min||e.parse(f.max)!==e.max}function zoomNumericalScale(e,t,n,o){const a=linearZoomDelta(e,t,n);const i={min:e.min+a.min,max:e.max-a.max};return updateRange(e,i,o,true)}function zoomLogarithmicScale(e,t,n,o){const a=logarithmicZoomRange(e,t,n);return updateRange(e,a,o,true)}function zoomRectNumericalScale(e,t,n,o){updateRange(e,linearRange(e,t,n),o,true)}const integerChange=e=>e===0||isNaN(e)?0:e<0?Math.min(Math.round(e),-1):Math.max(Math.round(e),1);function existCategoryFromMaxZoom(e){const t=e.getLabels();const n=t.length-1;e.min>0&&(e.min-=1);e.max<n&&(e.max+=1)}function zoomCategoryScale(e,t,n,o){const a=linearZoomDelta(e,t,n);e.min===e.max&&t<1&&existCategoryFromMaxZoom(e);const i={min:e.min+integerChange(a.min),max:e.max-integerChange(a.max)};return updateRange(e,i,o,true)}function scaleLength(e){return e.isHorizontal()?e.width:e.height}function panCategoryScale(e,t,n){const o=e.getLabels();const a=o.length-1;let{min:i,max:r}=e;const c=Math.max(r-i,1);const s=Math.round(scaleLength(e)/Math.max(c,10));const l=Math.round(Math.abs(t/s));let m;if(t<-s){r=Math.min(r+l,a);i=c===1?r:r-c;m=r===a}else if(t>s){i=Math.max(0,i-l);r=c===1?i:i+c;m=i===0}return updateRange(e,{min:i,max:r},n)||m}const l={second:500,minute:3e4,hour:18e5,day:432e5,week:3024e5,month:1296e6,quarter:5184e6,year:157248e5};function panNumericalScale(e,t,n,o=false){const{min:a,max:i,options:r}=e;const c=r.time&&r.time.round;const s=l[c]||0;const m=e.getValueForPixel(e.getPixelForValue(a+s)-t);const d=e.getValueForPixel(e.getPixelForValue(i+s)-t);return!(!isNaN(m)&&!isNaN(d))||updateRange(e,{min:m,max:d},n,!!o&&"pan")}function panNonLinearScale(e,t,n){return panNumericalScale(e,t,n,true)}const m={category:zoomCategoryScale,default:zoomNumericalScale,logarithmic:zoomLogarithmicScale};const d={default:zoomRectNumericalScale};const u={category:panCategoryScale,default:panNumericalScale,logarithmic:panNonLinearScale,timeseries:panNonLinearScale};function shouldUpdateScaleLimits(e,t,n){const{id:o,options:{min:a,max:i}}=e;if(!t[o]||!n[o])return true;const r=n[o];return r.min!==a||r.max!==i}function removeMissingScales(e,n){t(e,((t,o)=>{n[o]||delete e[o]}))}function storeOriginalScaleLimits(e,n){const{scales:o}=e;const{originalScaleLimits:a,updatedScaleLimits:i}=n;t(o,(function(e){shouldUpdateScaleLimits(e,a,i)&&(a[e.id]={min:{scale:e.min,options:e.options.min},max:{scale:e.max,options:e.options.max}})}));removeMissingScales(a,o);removeMissingScales(i,o);return a}function doZoom(e,t,n,o){const i=m[e.type]||m.default;a(i,[e,t,n,o])}function doZoomRect(e,t,n,o){const i=d[e.type]||d.default;a(i,[e,t,n,o])}function getCenter(e){const t=e.chartArea;return{x:(t.left+t.right)/2,y:(t.top+t.bottom)/2}}function zoom(e,n,o="none",i="api"){const{x:r=1,y:c=1,focalPoint:s=getCenter(e)}=typeof n==="number"?{x:n,y:n}:n;const l=getState(e);const{options:{limits:m,zoom:d}}=l;storeOriginalScaleLimits(e,l);const u=r!==1;const f=c!==1;const g=getEnabledScalesByPoint(d,s,e);t(g||e.scales,(function(e){e.isHorizontal()&&u?doZoom(e,r,s,m):!e.isHorizontal()&&f&&doZoom(e,c,s,m)}));e.update(o);a(d.onZoom,[{chart:e,trigger:i}])}function zoomRect(e,n,o,i="none",r="api"){const c=getState(e);const{options:{limits:s,zoom:l}}=c;const{mode:m="xy"}=l;storeOriginalScaleLimits(e,c);const d=directionEnabled(m,"x",e);const u=directionEnabled(m,"y",e);t(e.scales,(function(e){e.isHorizontal()&&d?doZoomRect(e,n.x,o.x,s):!e.isHorizontal()&&u&&doZoomRect(e,n.y,o.y,s)}));e.update(i);a(l.onZoom,[{chart:e,trigger:r}])}function zoomScale(e,t,n,o="none",i="api"){const r=getState(e);storeOriginalScaleLimits(e,r);const c=e.scales[t];updateRange(c,n,void 0,true);e.update(o);a(r.options.zoom?.onZoom,[{chart:e,trigger:i}])}function resetZoom(e,n="default"){const o=getState(e);const i=storeOriginalScaleLimits(e,o);t(e.scales,(function(e){const t=e.options;if(i[e.id]){t.min=i[e.id].min.options;t.max=i[e.id].max.options}else{delete t.min;delete t.max}delete o.updatedScaleLimits[e.id]}));e.update(n);a(o.options.zoom.onZoomComplete,[{chart:e}])}function getOriginalRange(e,t){const o=e.originalScaleLimits[t];if(!o)return;const{min:a,max:i}=o;return n(i.options,i.scale)-n(a.options,a.scale)}function getZoomLevel(e){const n=getState(e);let o=1;let a=1;t(e.scales,(function(e){const t=getOriginalRange(n,e.id);if(t){const n=Math.round(t/(e.max-e.min)*100)/100;o=Math.min(o,n);a=Math.max(a,n)}}));return o<1?o:a}function panScale(e,t,n,o){const{panDelta:r}=o;const c=r[e.id]||0;i(c)===i(t)&&(t+=c);const s=u[e.type]||u.default;a(s,[e,t,n])?r[e.id]=0:r[e.id]=t}function pan(e,n,o,i="none"){const{x:r=0,y:c=0}=typeof n==="number"?{x:n,y:n}:n;const s=getState(e);const{options:{pan:l,limits:m}}=s;const{onPan:d}=l||{};storeOriginalScaleLimits(e,s);const u=r!==0;const f=c!==0;t(o||e.scales,(function(e){e.isHorizontal()&&u?panScale(e,r,m,s):!e.isHorizontal()&&f&&panScale(e,c,m,s)}));e.update(i);a(d,[{chart:e}])}function getInitialScaleBounds(e){const t=getState(e);storeOriginalScaleLimits(e,t);const n={};for(const o of Object.keys(e.scales)){const{min:e,max:a}=t.originalScaleLimits[o]||{min:{},max:{}};n[o]={min:e.scale,max:a.scale}}return n}function getZoomedScaleBounds(e){const t=getState(e);const n={};for(const o of Object.keys(e.scales))n[o]=t.updatedScaleLimits[o];return n}function isZoomedOrPanned(e){const t=getInitialScaleBounds(e);for(const n of Object.keys(e.scales)){const{min:o,max:a}=t[n];if(o!==void 0&&e.scales[n].min!==o)return true;if(a!==void 0&&e.scales[n].max!==a)return true}return false}function isZoomingOrPanning(e){const t=getState(e);return t.panning||t.dragging}const clamp=(e,t,n)=>Math.min(n,Math.max(t,e));function removeHandler(e,t){const{handlers:n}=getState(e);const o=n[t];if(o&&o.target){o.target.removeEventListener(t,o);delete n[t]}}function addHandler(e,t,n,o){const{handlers:a,options:i}=getState(e);const r=a[n];if(r&&r.target===t)return;removeHandler(e,n);a[n]=t=>o(e,t,i);a[n].target=t;const c=n!=="wheel"&&void 0;t.addEventListener(n,a[n],{passive:c})}function mouseMove(e,t){const n=getState(e);if(n.dragStart){n.dragging=true;n.dragEnd=t;e.update("none")}}function keyDown(e,t){const n=getState(e);if(n.dragStart&&t.key==="Escape"){removeHandler(e,"keydown");n.dragging=false;n.dragStart=n.dragEnd=null;e.update("none")}}function getPointPosition(e,t){if(e.target!==t.canvas){const n=t.canvas.getBoundingClientRect();return{x:e.clientX-n.left,y:e.clientY-n.top}}return r(e,t)}function zoomStart(e,t,n){const{onZoomStart:o,onZoomRejected:i}=n;if(o){const n=getPointPosition(t,e);if(a(o,[{chart:e,event:t,point:n}])===false){a(i,[{chart:e,event:t}]);return false}}}function mouseDown(e,t){if(e.legend){const n=r(t,e);if(c(n,e.legend))return}const n=getState(e);const{pan:o,zoom:i={}}=n.options;if(t.button!==0||keyPressed(getModifierKey(o),t)||keyNotPressed(getModifierKey(i.drag),t))return a(i.onZoomRejected,[{chart:e,event:t}]);if(zoomStart(e,t,i)!==false){n.dragStart=t;addHandler(e,e.canvas.ownerDocument,"mousemove",mouseMove);addHandler(e,window.document,"keydown",keyDown)}}function applyAspectRatio({begin:e,end:t},n){let o=t.x-e.x;let a=t.y-e.y;const i=Math.abs(o/a);i>n?o=Math.sign(o)*Math.abs(a*n):i<n&&(a=Math.sign(a)*Math.abs(o/n));t.x=e.x+o;t.y=e.y+a}function applyMinMaxProps(e,t,n,{min:o,max:a,prop:i}){e[o]=clamp(Math.min(n.begin[i],n.end[i]),t[o],t[a]);e[a]=clamp(Math.max(n.begin[i],n.end[i]),t[o],t[a])}function getRelativePoints(e,t,n){const o={begin:getPointPosition(t.dragStart,e),end:getPointPosition(t.dragEnd,e)};if(n){const t=e.chartArea.width/e.chartArea.height;applyAspectRatio(o,t)}return o}function computeDragRect(e,t,n,o){const a=directionEnabled(t,"x",e);const i=directionEnabled(t,"y",e);const{top:r,left:c,right:s,bottom:l,width:m,height:d}=e.chartArea;const u={top:r,left:c,right:s,bottom:l};const f=getRelativePoints(e,n,o&&a&&i);a&&applyMinMaxProps(u,e.chartArea,f,{min:"left",max:"right",prop:"x"});i&&applyMinMaxProps(u,e.chartArea,f,{min:"top",max:"bottom",prop:"y"});const g=u.right-u.left;const p=u.bottom-u.top;return{...u,width:g,height:p,zoomX:a&&g?1+(m-g)/m:1,zoomY:i&&p?1+(d-p)/d:1}}function mouseUp(e,t){const n=getState(e);if(!n.dragStart)return;removeHandler(e,"mousemove");const{mode:o,onZoomComplete:i,drag:{threshold:r=0,maintainAspectRatio:c}}=n.options.zoom;const s=computeDragRect(e,o,{dragStart:n.dragStart,dragEnd:t},c);const l=directionEnabled(o,"x",e)?s.width:0;const m=directionEnabled(o,"y",e)?s.height:0;const d=Math.sqrt(l*l+m*m);n.dragStart=n.dragEnd=null;if(d<=r){n.dragging=false;e.update("none")}else{zoomRect(e,{x:s.left,y:s.top},{x:s.right,y:s.bottom},"zoom","drag");n.dragging=false;n.filterNextClick=true;a(i,[{chart:e}])}}function wheelPreconditions(e,t,n){if(keyNotPressed(getModifierKey(n.wheel),t))a(n.onZoomRejected,[{chart:e,event:t}]);else if(zoomStart(e,t,n)!==false){t.cancelable&&t.preventDefault();if(t.deltaY!==void 0)return true}}function wheel(e,t){const{handlers:{onZoomComplete:n},options:{zoom:o}}=getState(e);if(!wheelPreconditions(e,t,o))return;const i=t.target.getBoundingClientRect();const r=o.wheel.speed;const c=t.deltaY>=0?2-1/(1-r):1+r;const s={x:c,y:c,focalPoint:{x:t.clientX-i.left,y:t.clientY-i.top}};zoom(e,s,"zoom","wheel");a(n,[{chart:e}])}function addDebouncedHandler(e,t,n,o){n&&(getState(e).handlers[t]=debounce((()=>a(n,[{chart:e}])),o))}function addListeners(e,t){const n=e.canvas;const{wheel:o,drag:a,onZoomComplete:i}=t.zoom;if(o.enabled){addHandler(e,n,"wheel",wheel);addDebouncedHandler(e,"onZoomComplete",i,250)}else removeHandler(e,"wheel");if(a.enabled){addHandler(e,n,"mousedown",mouseDown);addHandler(e,n.ownerDocument,"mouseup",mouseUp)}else{removeHandler(e,"mousedown");removeHandler(e,"mousemove");removeHandler(e,"mouseup");removeHandler(e,"keydown")}}function removeListeners(e){removeHandler(e,"mousedown");removeHandler(e,"mousemove");removeHandler(e,"mouseup");removeHandler(e,"wheel");removeHandler(e,"click");removeHandler(e,"keydown")}function createEnabler(e,t){return function(n,o){const{pan:i,zoom:r={}}=t.options;if(!i||!i.enabled)return false;const c=o&&o.srcEvent;if(!c)return true;if(!t.panning&&o.pointerType==="mouse"&&(keyNotPressed(getModifierKey(i),c)||keyPressed(getModifierKey(r.drag),c))){a(i.onPanRejected,[{chart:e,event:o}]);return false}return true}}function pinchAxes(e,t){const n=Math.abs(e.clientX-t.clientX);const o=Math.abs(e.clientY-t.clientY);const a=n/o;let i,r;a>.3&&a<1.7?i=r=true:n>o?i=true:r=true;return{x:i,y:r}}function handlePinch(e,t,n){if(t.scale){const{center:o,pointers:a}=n;const i=1/t.scale*n.scale;const r=n.target.getBoundingClientRect();const c=pinchAxes(a[0],a[1]);const s=t.options.zoom.mode;const l={x:c.x&&directionEnabled(s,"x",e)?i:1,y:c.y&&directionEnabled(s,"y",e)?i:1,focalPoint:{x:o.x-r.left,y:o.y-r.top}};zoom(e,l,"zoom","pinch");t.scale=n.scale}}function startPinch(e,t,n){if(t.options.zoom.pinch.enabled){const o=r(n,e);if(a(t.options.zoom.onZoomStart,[{chart:e,event:n,point:o}])===false){t.scale=null;a(t.options.zoom.onZoomRejected,[{chart:e,event:n}])}else t.scale=1}}function endPinch(e,t,n){if(t.scale){handlePinch(e,t,n);t.scale=null;a(t.options.zoom.onZoomComplete,[{chart:e}])}}function handlePan(e,t,n){const o=t.delta;if(o){t.panning=true;pan(e,{x:n.deltaX-o.x,y:n.deltaY-o.y},t.panScales);t.delta={x:n.deltaX,y:n.deltaY}}}function startPan(e,t,n){const{enabled:o,onPanStart:i,onPanRejected:r}=t.options.pan;if(!o)return;const c=n.target.getBoundingClientRect();const s={x:n.center.x-c.left,y:n.center.y-c.top};if(a(i,[{chart:e,event:n,point:s}])===false)return a(r,[{chart:e,event:n}]);t.panScales=getEnabledScalesByPoint(t.options.pan,s,e);t.delta={x:0,y:0};handlePan(e,t,n)}function endPan(e,t){t.delta=null;if(t.panning){t.panning=false;t.filterNextClick=true;a(t.options.pan.onPanComplete,[{chart:e}])}}const f=new WeakMap;function startHammer(t,n){const o=getState(t);const a=t.canvas;const{pan:i,zoom:r}=n;const c=new e.Manager(a);if(r&&r.pinch.enabled){c.add(new e.Pinch);c.on("pinchstart",(e=>startPinch(t,o,e)));c.on("pinch",(e=>handlePinch(t,o,e)));c.on("pinchend",(e=>endPinch(t,o,e)))}if(i&&i.enabled){c.add(new e.Pan({threshold:i.threshold,enable:createEnabler(t,o)}));c.on("panstart",(e=>startPan(t,o,e)));c.on("panmove",(e=>handlePan(t,o,e)));c.on("panend",(()=>endPan(t,o)))}f.set(t,c)}function stopHammer(e){const t=f.get(e);if(t){t.remove("pinchstart");t.remove("pinch");t.remove("pinchend");t.remove("panstart");t.remove("pan");t.remove("panend");t.destroy();f.delete(e)}}function hammerOptionsChanged(e,t){const{pan:n,zoom:o}=e;const{pan:a,zoom:i}=t;return o?.zoom?.pinch?.enabled!==i?.zoom?.pinch?.enabled||(n?.enabled!==a?.enabled||n?.threshold!==a?.threshold)}var g="2.2.0";function draw(e,t,n){const o=n.zoom.drag;const{dragStart:a,dragEnd:i}=getState(e);if(o.drawTime!==t||!i)return;const{left:r,top:c,width:s,height:l}=computeDragRect(e,n.zoom.mode,{dragStart:a,dragEnd:i},o.maintainAspectRatio);const m=e.ctx;m.save();m.beginPath();m.fillStyle=o.backgroundColor||"rgba(225,225,225,0.3)";m.fillRect(r,c,s,l);if(o.borderWidth>0){m.lineWidth=o.borderWidth;m.strokeStyle=o.borderColor||"rgba(225,225,225)";m.strokeRect(r,c,s,l)}m.restore()}var p={id:"zoom",version:g,defaults:{pan:{enabled:false,mode:"xy",threshold:10,modifierKey:null},zoom:{wheel:{enabled:false,speed:.1,modifierKey:null},drag:{enabled:false,drawTime:"beforeDatasetsDraw",modifierKey:null},pinch:{enabled:false},mode:"xy"}},start:function(t,n,o){const a=getState(t);a.options=o;Object.prototype.hasOwnProperty.call(o.zoom,"enabled")&&console.warn("The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.");(Object.prototype.hasOwnProperty.call(o.zoom,"overScaleMode")||Object.prototype.hasOwnProperty.call(o.pan,"overScaleMode"))&&console.warn("The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).");e&&startHammer(t,o);t.pan=(e,n,o)=>pan(t,e,n,o);t.zoom=(e,n)=>zoom(t,e,n);t.zoomRect=(e,n,o)=>zoomRect(t,e,n,o);t.zoomScale=(e,n,o)=>zoomScale(t,e,n,o);t.resetZoom=e=>resetZoom(t,e);t.getZoomLevel=()=>getZoomLevel(t);t.getInitialScaleBounds=()=>getInitialScaleBounds(t);t.getZoomedScaleBounds=()=>getZoomedScaleBounds(t);t.isZoomedOrPanned=()=>isZoomedOrPanned(t);t.isZoomingOrPanning=()=>isZoomingOrPanning(t)},beforeEvent(e,{event:t}){if(isZoomingOrPanning(e))return false;if(t.type==="click"||t.type==="mouseup"){const t=getState(e);if(t.filterNextClick){t.filterNextClick=false;return false}}},beforeUpdate:function(e,t,n){const o=getState(e);const a=o.options;o.options=n;if(hammerOptionsChanged(a,n)){stopHammer(e);startHammer(e,n)}addListeners(e,n)},beforeDatasetsDraw(e,t,n){draw(e,"beforeDatasetsDraw",n)},afterDatasetsDraw(e,t,n){draw(e,"afterDatasetsDraw",n)},beforeDraw(e,t,n){draw(e,"beforeDraw",n)},afterDraw(e,t,n){draw(e,"afterDraw",n)},stop:function(t){removeListeners(t);e&&stopHammer(t);removeState(t)},panFunctions:u,zoomFunctions:m,zoomRectFunctions:d};export{p as default,pan,resetZoom,zoom,zoomRect,zoomScale};

